# 1、new/delete和malloc/free关系

`delete`会调用对象的析构函数,和`new`对应。`free`只会释放内存，`new`调用构造函数。`malloc`与`free`是C++/C语言的标准库函数，`new/delete`是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

总结：**new和delete配套使用,是C++运算符，一般用于自定义数据类型的创建和释放。malloc和free是库函数**。



# 2、delete与 delete []区别

- delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套

```c++
MemTest *mTest1 = new MemTest[10];

MemTest *mTest2 = new MemTest;

int *pInt1 = new int[10];

int *pInt2 = new int;

delete[] pInt1;                // -1-

delete[] pInt2;                // -2-

delete[] mTest1;            // -3-

delete[] mTest2;            // -4-
```

- 在-4-处报错。
- 这就说明：对于**内建简单数据类型，delete和delete[]功能是相同的**。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。**内部数据类型没有析构函数**，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。



# 3、C++有哪些性质（面向对象特点）

封装，继承和多态。



# 4、子类析构时要调用父类的析构函数吗？

析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。类似回家进入房间一样，先打开外面大门，再打开卧室门。出去的时候，先关上卧室门，再关上外面大门。



# 5、多态，虚函数，纯虚函数，抽象类

- 多态：是**对于不同对象接收相同消息时产生不同的动作**。C++的多态性具体体现在运行和编译两个方面：在程序**运行时**的多态性通过继承和虚函数来体现；
- 在程序**编译时**多态性体现在函数和运算符的重载上；
- 虚函数(virtual {method body})：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。
- 纯虚函数(virtual { } = 0;)的**作用**：<u>在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义</u>。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。
- 从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。
- 抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。



# 6、求下面函数的返回值（微软）

```C++
int func(x)
{
	int countx = 0;
    while (x)
	{
		coutx++;
		x = x & (x - 1);
	}
	return countx;
}
```

假定x = 9999。 答案：8

思路：将x转化为2进制，看含有的1的个数。



# 7、什么是“引用”？申明和使用“引用”要注意哪些问题？

- 答：引用就是某个目标变量的“别名”(alias)，对引用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记**要对其进行初始化**。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。**不能建立数组的引用**。
- 总结：引用是别名，引用**一定要初始化**，引用不是数据类型，不占存储单元，**不能建立数组的引用**。



# 8、将“引用”作为函数参数有哪些特点？

- （1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
- （2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
- （3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而**引用更容易使用，更清晰**。





# 9、在什么时候需要使用“常引用”？

- 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &引用名=目标变量名；

```C++
// 例1
int a;
const int &ra = a;
ra = 1;                // 错误
a = 1;                // 正确
 
// 例2
string foo();
void bar(string &s);

// 下面表达式非法
bar(foo());
bar("hello world");
```

原因在于foo( )和"hello world"串都会产生一个临时对象，而**在C++中，这些`临时对象`都是const类型**的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const 。

